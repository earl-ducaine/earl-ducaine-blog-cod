* Factories and introspection in CLOS and MOP

  One of the sources of Common Lisp's reputation for difficulty is
  that it uses a speciallized terminology: for instance you don't have
  global variables instead they're called special.  let doesn't create
  a variable, but instead a variable binding.  Functions are not
  executed within the local scope of the let, but rather "executes a
  series of forms that use these bindings".  This specialized
  terminology allows you to talk about features and constructs in CL
  with greater precision than you could using a more familiar, but
  ambiguous terminology.

  CLOS carries on this pattern by relying heavily on such features as
  generic functions, slots, initialization arguments, reader function,
  writer function.  All of which obscure the classic object oriented
  aspects of CLOS.  So, much so that Peter Norvig wonders in his
  Paradigms of Artificial Intelligence Programming whether CLOS is
  object oriented.  Aspects in which it's not include the fact that 
  it doesn't provide modular objects with information hiding and that
  its generic function system is too powerful to be considered
  strictly OO.  

  Even considering the odball nature of CLOS as an object system, Meta
  Object Protocol (MOP) seems to diverge even more.  A whole
  convention has grow up around meta object programming that renders
  the MOP seem very alien.  

  But before one dismisses MOP as too arcane or a relic of a bygon age
  before object oriented tools and conventions had coalesced into
  their current form, it's worthwhile keeping in mind CLOS is still an
  extrodinarily powerful object system, and MOP was developed as small
  subset of tools which could be used to build a full featured CLOS
  system. In short MOP provides a fascility to build an object system
  taylored to your specific needs, removing aspects of CLOS that are
  cumbersome, not applicable, or too obscure for your system.  While
  MOP is not officially part of the ansi standard it is well supported
  across modern Lisp Systems.

  One of the keys in understanding MOP like many things in CL is to be
  able to map its abstract feature to familiar, cocreate tasks.  In
  this excercise we'll use MOP to create a factory tools for
  introspection analagous to what can be created in more contemporary
  OO systems like Java.

** Factories

   A factory is an object used to create classes.  It extends the OO
   pattern, where classes are templates used to create objects, so
   that you can use classes as templates to create other classes,
   which of course is core aspect of MOP.

   To motivate our new class lets take a look at the following:

   #+BEGIN_SRC lisp :tangle start-swank-server.lisp
     (defclass disk-info ()
       ((label :accessor :label :initarg :label)
         (cyls :accessor :cyls :initarg :cyls)
         (heads :accessor :heads :initarg :heads)
         (blockspertrack :accessor :blockspertrack :initarg :blockspertrack)
         (mcr :accessor :mcr :initarg :mcr)
         (lod :accessor :lod :initarg :lod)
         (brand :accessor :brand :initarg :brand)
         (text :accessor :text :initarg :text)
         (comment :accessor :comment :initarg :comment)))
   #+END_SRC
   
   There is obviously a pattern here, with each slot having an
   accessor and initform formed in the same way from the slot name.
   In many applications a large number of classes with many slots need
   might need to be created using the same conventions.  Eliminating
   as much boilerplating as possible makes code more comprehendible
   and reduces the likelihood of making a clarical error.  What would
   be nice is to be able to define the above class in the following
   way:

   #+BEGIN_SRC lisp :tangle start-swank-server.lisp
     (disk-kit-defclass disk-info
       '(label cyls heads blockspertrack mcr lod brand text comment))
   #+END_SRC

   The 'define-factory' function is the somewhat obscurely name
   ensure-class.  It it is a functional wrapper to the defclass macro.
   Its various keyword arguments are the various sections of the
   defclass macro in 'canonical form.  For example, the above defclass
   form would look like the following when expanded under expandmacro 
 
  #+BEGIN_SRC lisp :tangle start-swank-server.lisp
    (closer-mop:ensure-class
     :disk-info
     :direct-slots
     (list '(:name label :readers (:label) :initargs '(:label))
           '(:name cyls :readers (:cyls) :initargs '(:cyls))


      (list* :name 'heads :readers '(:heads) :writers
             '((setf :heads)) :initargs '(:heads)
             'sb-pcl::source
      (list* :name 'blockspertrack :readers
             '(:blockspertrack) :writers
             '((setf :blockspertrack)) :initargs
             '(:blockspertrack) 'sb-pcl::source
      (list* :name 'mcr :readers '(:mcr) :writers
             '((setf :mcr)) :initargs '(:mcr)
             'sb-pcl::source
      (list* :name 'lod :readers '(:lod) :writers
             '((setf :lod)) :initargs '(:lod)
             'sb-pcl::source
      (list* :name 'brand :readers '(:brand) :writers
             '((setf :brand)) :initargs '(:brand)
             'sb-pcl::source
      (list* :name 'text :readers '(:text) :writers
             '((setf :text)) :initargs '(:text)
             'sb-pcl::source
      (list* :name 'comment :readers '(:comment) :writers
             '((setf :comment)) :initargs '(:comment)
             'sb-pcl::source
     (list :direct-default-initargs nil)
     '(:comment :text :brand :lod :mcr :blockspertrack
       :heads :cyls :label)
     '((setf :comment) (setf :text) (setf :brand)
       (setf :lod) (setf :mcr) (setf :blockspertrack)
       (setf :heads) (setf :cyls) (setf :label))
     '(comment text brand lod mcr blockspertrack heads
       cyls label)
     (sb-c:source-location)))
   #+END_SRC



   #+BEGIN_SRC lisp :tangle start-swank-server.lisp
     (defun disk-kit-defclass ()
       (closer-mop:ensure-class :disk-info
                                :direct-slots
                                '((:name mach
                                   :initargs (mach)           ; initarg(s)
                                   :readers (plane-altitude)) ; accessor(s)
                                  )))
  
     (ensure-class :disk-info ()
       '(label cyls heads blockspertrack mcr lod brand text comment))
   #+END_SRC


